const crypto = require('crypto')
const util = require('util')

const cipherName = 'aes-256-cbc'

/**
 * This decrypts data that has been encrypted with encrypt().
 * 
 * The general algorithm for decrypting is to first
 * decrypt the key using the password. Then decrypt the data with the 
 * decrypted key.
 * 
 * More detailed, the pass is mixed with the salt to make a
 * key to decrypt the key parameter with. That decryption requires
 * the iv1 initialization vector.
 * 
 * With the decrypted key, the second initialization vector is used
 * to decrypt data.
 * 
 * This complexity is to allow for cheap changes in encryption 
 * pass phrase without needing to re-encrypt every file.
 * 
 * @param {String} pass The document password.
 * @param {String} salt The salt to generate a key from pass.
 * @param {String} iv1 The initialization vector to decrypt key.
 * @param {String} iv2 The initialization vector to decrypt data.
 * @param {String} key The encrypted key for the data.
 * @param {String} data The encrypted file to decrypt.
 * @param {Function} callback A callback that takes (err, data) as arguments.
 */
export function decrypt(pass, salt, iv1, iv2, key, data, callback) {

    salt = Buffer.from(salt, 'hex')
    iv1 = Buffer.from(iv1, 'hex')
    iv2 = Buffer.from(iv2, 'hex')
    key = Buffer.from(key, 'hex')

    util.promisify(crypto.pbkdf2)(pass, salt, 100000, 32, 'sha512').then(derivedKey => 
        new Promise((accept, reject) => {
            try {
                var cipher = crypto.createDecipheriv(cipherName, derivedKey, iv1)
                var decryptedKey = ''
                cipher.on('readable', () => {
                    var chunk
                    while (null !== (chunk = cipher.read())) {
                        decryptedKey += chunk.toString('hex')
                    }                    
                })
                cipher.on('end', () => accept(decryptedKey))
                cipher.write(key, 'hex')
                cipher.end()
            }
            catch (e) {
                reject(e)
            }
        }).then(key => {
            key = Buffer.from(key, 'hex')
            return new Promise((accept, reject) => {
                try {
                    var cipher = crypto.createDecipheriv(cipherName, key, iv2)
                    var decryptedFile = ''
                    cipher.on('readable', () => {
                        var chunk
                        while (null !== (chunk = cipher.read())) {
                            decryptedFile += chunk
                        }                    
                    })
                    cipher.on('end', () => accept(decryptedFile))
                    cipher.write(data, 'hex')
                    cipher.end()
                }
                catch (e) {
                    reject(e)
                }
            }).then(k => key = k)
        })
    ).then(d => {
        callback(null, d)
    }).catch(e => callback(e, null))
}

/**
 * This function uses pass to generate a symmetric encryption key.
 * Along with this a salt is generated and an initialization vector, iv1.
 * 
 * The generated key and iv1 are used to encrypt an intermediate key. The
 * encrypted key is returned in props as `key`. The salt and initialization 
 * vector are returned as `salt` and `iv1`. There is still more to do
 * to finally encrypt the user's data.
 * 
 * Another initialization vector, `iv2`, is generated. The intermediate key
 * is used with the second initialization vector to encrypt the user's data.
 * 
 * All the keying parameters and values are returned along with the user's data
 * in a properties map passed to the callback function.
 * 
 * The parameters are `salt` used to generate the first key from the user's 
 * password. The first initialization vector is returned as `iv1`. The
 * encrypted intermediate key is returned as `key`. The second initialization
 * vector, which is used to encrypt the user's data, is returned as `iv2`.
 * Finally, the user's data is returned as `body`.
 * 
 * @param {String} pass The password to use to encrypt data with.
 * @param {String} data The dat to encrypt.
 * @param {Function} callback Callback function that takes (err, props) where
 * props is the properties generated by this call.
 */
export function encrypt(pass, data, callback) {
    /* eslint-disable no-unused-vars */

    let props = {}

    // We are using util.promisify to flatten out error reporting.
    // Any error and we should abort encryption.
    util.promisify(crypto.randomBytes)(16).then(salt =>
    util.promisify(crypto.pbkdf2)(pass, salt, 100000, 32, 'sha512').then(derivedKey => 
    util.promisify(crypto.randomBytes)(16).then(iv => 
    util.promisify(crypto.randomBytes)(32).then(key => {

        props['salt'] = salt.toString('hex')
        props['iv1'] = iv.toString('hex')
        props['cipher'] = cipherName

        var encryptedKeyPromise = new Promise((accept, reject) => {
            // Encrypt the encryption key with the derivedKey.
            var cipher = crypto.createCipheriv(cipherName, derivedKey, iv)
            cipher.setEncoding('hex');
            var encryptedKey = ''
            cipher.on('data', (chunk) => encryptedKey += chunk);
            cipher.on('end', () => accept(encryptedKey));
            cipher.write(key);
            cipher.end();
        }).then(encryptedKey => {
            props['key'] = encryptedKey
            return encryptedKey
        })

        var encryptedFileBody = new Promise((accept, reject) => {
            // Get another initialization vector.
            crypto.randomBytes(16, (err, iv) => {
                if (err) {
                    reject(err)
                } else {                    
                    props['iv2'] = iv.toString('hex')
                    var cipher = crypto.createCipheriv('aes-256-cbc', key, iv)
                    cipher.setEncoding('hex')
                    var encryptedFile = ''
                    cipher.on('data', (chunk) => encryptedFile += chunk)
                    cipher.on('end', () => accept(encryptedFile))
                    cipher.write(data);
                    cipher.end();
                }
            })
        })

        encryptedKeyPromise.
            then(() => encryptedFileBody).
            then(body => callback(null, { body, ...props })).
            catch(err => callback(err, {}))
    })
    )
    )
    )
}

export default {
    encrypt,
    decrypt
}